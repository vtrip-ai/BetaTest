-- (Giữ nguyên header, UI và cấu trúc như MT_AutoLucky_vNext)
-- Thay thế CHỈ function attemptCollectTarget bằng phiên bản nâng cấp sau:

-- Helper: snapshot tất cả Number/Int value dưới player (leaderstats + player descendants)
local function snapshotPlayerNumbers(player)
    local snap = {}
    local function scan(obj)
        for _, v in pairs(obj:GetChildren()) do
            if v:IsA("NumberValue") or v:IsA("IntValue") then
                snap[v] = v.Value
            end
            scan(v)
        end
    end
    -- leaderstats thường ở player root
    if player then
        local leader = player:FindFirstChild("leaderstats")
        if leader then scan(leader) end
        -- scan player itself for any Number/Int values
        scan(player)
    end
    return snap
end

local function compareSnapshots(before, after)
    -- return true, {name=diff,...} if any numeric increased
    local diffs = {}
    for v, old in pairs(before) do
        local ok, curr = pcall(function() return v.Value end)
        if ok and type(curr) == "number" and curr > old then
            table.insert(diffs, {obj = v, before = old, after = curr})
        end
    end
    return #diffs > 0, diffs
end

-- Attempt collect target: combines Touched + Value-change + position heuristics
local function attemptCollectTarget(target)
    if not target or not target.Parent then return false, "no_target" end
    local char = lp.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return false, "no_hrp" end

    -- pre-snapshot numeric values
    local beforeSnap = snapshotPlayerNumbers(lp)

    local touchedByPlayer = false
    local conn
    if target and target:IsA("BasePart") then
        conn = target.Touched:Connect(function(hit)
            if not hit then return end
            if not lp.Character then return end
            if hit:IsDescendantOf(lp.Character) then
                touchedByPlayer = true
            end
        end)
    else
        -- if target is not a BasePart, try to find a primary part inside it
        local primary = target:IsA("Model") and target.PrimaryPart or nil
        if primary and primary:IsA("BasePart") then
            conn = primary.Touched:Connect(function(hit)
                if not hit then return end
                if hit:IsDescendantOf(lp.Character) then
                    touchedByPlayer = true
                end
            end)
        end
    end

    local startTime = os.clock()
    local attempts = 0
    local succeeded = false
    local detectionMethod = nil
    local detectionInfo = ""

    while attempts < MAX_ATTEMPTS_PER_TARGET and (os.clock() - startTime) < MAX_SECONDS_PER_TARGET do
        if not lp.Character then break end
        char = lp.Character
        hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then break end

        -- Quick check: immediate success if player already far from target (maybe teleported instantly)
        if (hrp.Position - target.Position).Magnitude > 15 then
            succeeded = true
            detectionMethod = "moved_away"
            detectionInfo = ("dist=%.1f"):format((hrp.Position - target.Position).Magnitude)
            break
        end

        -- Move close and firetouchinterest
        pcall(function()
            hrp.CFrame = target.CFrame + Vector3.new(0, 1.2, 0)
        end)
        task.wait(math.max(0.12, MOVE_INTERVAL * 0.5))

        pcall(function()
            firetouchinterest(hrp, target, 0)
            task.wait(0.035)
            firetouchinterest(hrp, target, 1)
        end)

        attempts = attempts + 1

        -- Wait short while and check detection signals
        local checkDeadline = os.clock() + AFTER_TOUCH_SETTLE
        while os.clock() < checkDeadline do
            -- 1) if touched event fired locally
            if touchedByPlayer then
                -- double-check maybe server registers reward later -> also check numeric after short wait
                task.wait(0.12)
                local afterSnap = snapshotPlayerNumbers(lp)
                local changed, diffs = compareSnapshots(beforeSnap, afterSnap)
                if changed then
                    succeeded = true
                    detectionMethod = "touched+value_increase"
                    detectionInfo = ("value_increase_count=%d"):format(#diffs)
                    break
                else
                    -- even if no value change, accept Touched as success for pure obby that doesn't reward value
                    succeeded = true
                    detectionMethod = "touched_local"
                    detectionInfo = ("attempts=%d"):format(attempts)
                    break
                end
            end

            -- 2) check numeric increase regardless of touched
            local afterSnap2 = snapshotPlayerNumbers(lp)
            local changed2, diffs2 = compareSnapshots(beforeSnap, afterSnap2)
            if changed2 then
                succeeded = true
                detectionMethod = "value_increase"
                detectionInfo = ("value_increase_count=%d"):format(#diffs2)
                break
            end

            -- 3) check if target was moved/disabled by server (some obbies change property)
            if not target.Parent or not target:IsDescendantOf(workspace) then
                succeeded = true
                detectionMethod = "target_removed"
                detectionInfo = "removed"
                break
            end

            task.wait(0.03)
        end

        if succeeded then break end

        -- small pause before next attempt
        task.wait(0.12)
    end

    -- cleanup connection
    if conn and conn.Connected then
        pcall(function() conn:Disconnect() end)
    end

    if succeeded then
        return true, ("%s %s"):format(tostring(detectionMethod or "unknown"), tostring(detectionInfo or ""))
    else
        -- final fallback: re-scan numeric values once more before giving up
        local afterFinal = snapshotPlayerNumbers(lp)
        local changedFinal, diffsFinal = compareSnapshots(beforeSnap, afterFinal)
        if changedFinal then
            return true, ("value_increase_final=%d"):format(#diffsFinal)
        end
        return false, ("failed attempts=%d elapsed=%.1fs"):format(attempts, os.clock() - startTime)
    end
end

-- (Phần còn lại của script vNext giữ nguyên — UI, loop, ServerHopImmediate, v.v.)
